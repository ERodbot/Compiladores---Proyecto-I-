package Analizer;
import java_cup.runtime.*;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
//manejo de tabla de simbolos 
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


action code {:



    public boolean isType(String type) {
        return type.equals("char") || type.equals("int") || type.equals("string") || type.equals("float") || type.equals("bool") || type.equals("void");
    };

:}

parser code {:
  LexerCup lex;
  int literalId = 0;
  int labelId = 0;
  

  public ArrayList<String> errores = new ArrayList<String>();
  @SuppressWarnings("deprecation")
  public Sintax(LexerCup lex){
    this.lex=lex;
    this.symbolFactory= new DefaultSymbolFactory();
  };
    public void syntax_error(Symbol cur_token){

     
        if (cur_token!=null){
            String cadenaError="Error de sintaxis en la línea " + (cur_token.left+1) + " y columna " + (cur_token.right+1)+ ". Token que generó el error: "+ lex.yytext();
            System.err.println(cadenaError);
            this.errores.add(cadenaError);
        
        }else{
            String cadenaError="Error de sintaxis en la línea " + (cur_token.left+1) + " y columna " + (cur_token.right+1)+". Token: "+ cur_token.value;
            System.err.println(cadenaError);
            this.errores.add(cadenaError);
        }
	
    }

    public void unrecovered_syntax_error(Symbol token) throws java.lang.Exception {
        if (token!=null){
            throw new Exception("Error de sintaxis no puede ser recuperado. Encontrado en la línea " + (token.left+1) + " columna " + (token.right+1) + ". Token que generó el error: " + lex.yytext());
  
        }
        else{
            throw new Exception("Error de sintaxis no puede ser recuperado. Encontrado en la línea " + (token.left+1) + " columna " + (token.right+1) + ". Token que generó el error: " + token.value);
        }
    
    }

    public TypeEx validarTipado(String operand, Expresion a, Expresion b, ArrayList<TypeEx> validTypes) {
    // validar que los tipos de a y b sean iguales
    if (a.getType() != b.getType()) {
      System.out.println("Error semántico: Los tipos de datos son incompatibles: " + a.getType().toString() + " y " + b.getType().toString() + "con la operacion" + operand +" en la linea " + lex.getLine() + " columna " + lex.getColumn());
      return TypeEx.NULL;
    }
    // validar que el tipo de a esté en la lista de tipos validos
    if (!validTypes.contains(a.getType())) {
      System.out.println("Error semántico: Tipo de dato ilegal: " + a.getType().toString() + " para operacion " + operand + "en la linea " + lex.getLine() + " columna " + lex.getColumn());
      return TypeEx.NULL;
    }

    return a.getType();
  }

  // overloading del metodo pero unario
  public TypeEx validarTipado(String operand, Expresion a, ArrayList<TypeEx> validTypes) {
    // validar que el tipo de a esté en la lista de tipos validos
    if (!validTypes.contains(a.getType())) {
      System.out.println("Error semántico: "  + "Tipo ilegal de dato" + a.getType().toString() + " para operacion " + operand + "en la linea " + lex.getLine() + " columna " + lex.getColumn());
      return TypeEx.NULL;
    }
    return a.getType();
  }


:}

init with {: :};

scan with {: return lex.next_token(); :};

// Terminals
// Data Types
terminal NOEL, NICOLAS, SANTA, COLACHO, CLAUS;
//Parenthesis
terminal ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO;
//Separator
terminal CHIMENEA;
//Literals numbers
terminal l_NICOLAS, l_NOEL;
//Literal strings
terminal l_SANTA;
//Literal char
terminal l_COLACHO;
// Control Structures
terminal ELFO, HADA, DUENDE, ENVUELVE, HACE, REVISA, ENVIA, CORTA;
// Input/Output Functions
terminal NARRA, ESCUCHA;
//null
terminal NARIZROJA;
//void 
terminal SINREGALO;
// Relational Operators
terminal ALABASTRO, EVERGEEN, UPATREE, MINSTIX, MARY, OPENSLAE;
// Logical Operators
terminal GASPAR, MELCHOR, BALTASAR;
// Assignment
terminal ENTREGA;
// Boolean Literals
terminal l_t_CLAUS, l_f_CLAUS;
// Unary Operators
terminal GRINCH, QUIEN;
// Binary Arithmetic Operators
terminal RODOLFO, TRUENO, RELAMPAGO, JUGUETON, COMETA, CUPIDO;
//Main 
terminal MAINNAVIDAD;
//Functions
terminal RECORRIDO;
//Variables 
terminal LOCALCOLOCARREGALO;
// Identifier
terminal PERSONA;
// End of Line
terminal FINREGALO;
// Lexical Error
terminal ERRORNOTRECOGNIZED;

//no terminal 
non terminal   navidad, navidadAux, saco_function_definition_aux, saco_function_definition, arbol_constant, gorro_navidad_type_specifier, statement_risa_santa, lazo_io_statement, belen_function_call_statement,
               calcetin_compound_statement, empaque_block_item_list, carta_block_item, deseos_selection_statement, lapiz_papel_if_statement,
			   tradiciones_elif_lista_statements, tradicion_elif_statement, caramelo_iteration_statement, calcetin_jump_statement, nochebuena_initializer, 
			   estrella_assign_array, decorativo_array_elem, candelabro_assignment_expression, pesebre_args, pesebre_arg, reyes_magicos_list_expr, incienzo_expression, diciembre_operation_array, bastoncillo_arithmetic_expr, galleta_logic_expr, 
			   leche_relational_expr, belen_function_call_expression;


// Precedence and associativity

precedence left TRUENO, RODOLFO; //resta
precedence left JUGUETON, RELAMPAGO;  //division, multiplicacion
precedence left CUPIDO, COMETA; // mod, exponente
precedence left QUIEN, GRINCH; // Increment and decrement
precedence left ALABASTRO, MINSTIX, UPATREE, MARY;
precedence left OPENSLAE, EVERGEEN;
precedence left GASPAR;
precedence left MELCHOR; 
precedence left BALTASAR;


start with navidad;

//produccion de inicio
navidad ::= {:System.out.println("Inicio de parseo");:} 
            navidadAux 
            {: 
                SymbolTableManager.imprimirTablaSimbolos(); 
                SymbolTableManager.guardarTablaSimbolos();
                if (FunctionManager.findFunction("main") == null) {
                    System.out.println("Error: no existe una función main para el programa");
                };
                FunctionManager.isNoReturnForNonVoidFunc(); 
                System.out.println("Fin de parseo");
            :}; 

navidadAux ::= saco_function_definition
	| navidadAux saco_function_definition
    | navidadAux error
    | error
	;

//definicion de funciones
saco_function_definition ::= saco_function_definition_aux:funcD  calcetin_compound_statement {:
    String functionId = (String)funcD; 
:}; 

saco_function_definition_aux ::=  RECORRIDO:f NOEL MAINNAVIDAD ABRECUENTO CIERRACUENTO    
        {:
            if (FunctionManager.findFunction("main") != null) {
                System.out.println("Error semántico: la función main ya fue declarada. Linea: " + lex.getLine() + "columna" + lex.getColumn());
            } else {    
                SymbolTableManager.definirHash("main");
                RESULT = "main";
                SymbolTableManager.anadirSimbolo(new SymbolTObj("function", "integer", "Main"));
                FunctionManager.addFunctionIdentifier(new FunctionIdentifier("main", TypeEx.INT, true, new TypeEx[] {}));
            }
        :}
    | RECORRIDO:f gorro_navidad_type_specifier:ty  PERSONA:id ABRECUENTO                                    
        {:
            var type = ty.toString();
            if (!isType(type)) {
                System.out.println("Error semántico: la función no posee un tipo de retorno válido. Linea: " + lex.getLine() + "columna" + lex.getColumn());
            } else {
                if (FunctionManager.findFunction(id.toString()) != null) {
                    System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " ya declarada");
                } else {
                    RESULT = id.toString();
                    SymbolTableManager.definirHash(id.toString());
                    SymbolTableManager.anadirSimbolo(new SymbolTObj("function", type, id.toString()));
                    FunctionManager.addFunctionIdentifier(new FunctionIdentifier(id.toString(), Expresion.tipoFromString(type), false, new TypeEx[] {}));
                }
            }
        :}                                                         
     pesebre_args CIERRACUENTO                                                                                                      
    | RECORRIDO:f gorro_navidad_type_specifier:ty PERSONA:id ABRECUENTO CIERRACUENTO                       
        {:
            var type = (String)ty;
            if (!isType(type)) {
                System.out.println("Error semántico: la función no posee un tipo de retorno válido. Linea: " + lex.getLine() + "columna" + lex.getColumn());
            } else {
                if (FunctionManager.findFunction(id.toString()) != null) {
                    System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " ya declarada");
                } else {
                    SymbolTableManager.definirHash(id.toString());
                    RESULT = id.toString();
                    SymbolTableManager.anadirSimbolo(new SymbolTObj("function", ty.toString(), id.toString()));
                    FunctionManager.addFunctionIdentifier(new FunctionIdentifier(id.toString(), Expresion.tipoFromString(ty.toString()), false, new TypeEx[] {}));
                }
            }
        :}                                                         
    |error CIERRACUENTO
    ;

//constantes
arbol_constant ::= l_NOEL:l_int {:RESULT =  new Expresion(l_int, TypeEx.INT);:}	
    | l_NICOLAS:l_flo {:RESULT = new Expresion(l_flo, TypeEx.FLOAT);:} 
    | l_COLACHO:l_ch {: RESULT = new Expresion(l_ch, TypeEx.CHAR);:}
    | l_SANTA:l_st {:RESULT = new Expresion(l_st, TypeEx.STRING);:}
    | l_t_CLAUS:l_t {:RESULT = new Expresion(l_t, TypeEx.BOOL);:} 
    | l_f_CLAUS:l_f {:RESULT = new Expresion(l_f, TypeEx.BOOL);:}
    | NARIZROJA:nil {:RESULT = new Expresion(nil, TypeEx.NULL);:};


//Argumentos de una funcion
reyes_magicos_list_expr ::=  incienzo_expression:expr 
    {:
        var arrayExpr = new ArrayList<Expresion>();
        arrayExpr.add((Expresion)expr);
        RESULT = arrayExpr;
    :} 
    | reyes_magicos_list_expr:listExpr CHIMENEA incienzo_expression: expr
    {:
        ArrayList arrayExpr = (ArrayList<Expresion>)listExpr;
        arrayExpr.add((Expresion)expr);
        RESULT = arrayExpr;
    :};


//tipos
gorro_navidad_type_specifier ::= SINREGALO:sr {:RESULT = sr;:}
  | COLACHO:c {:RESULT = c;:}
  | SANTA:s {:RESULT = s;:}
  | NOEL:n {:RESULT = n;:}
  | NICOLAS:ni {:RESULT = ni;:}
  | CLAUS:cl {:RESULT = cl;:}
  ;

//estatuo 
statement_risa_santa ::= calcetin_compound_statement
	| candelabro_assignment_expression
	| deseos_selection_statement
	| caramelo_iteration_statement
	| calcetin_jump_statement
    | lazo_io_statement
	| belen_function_call_statement
    | error FINREGALO 
    | error CIERRAREGALO
	;

//estatuo de input/output
lazo_io_statement ::= NARRA ABRECUENTO reyes_magicos_list_expr:argsList CIERRACUENTO FINREGALO
    {:
        var exprargs = (ArrayList<Expresion>)argsList;
        for (Expresion iexpr : exprargs) {
            switch (iexpr.getType()) {
                case STRING:
                    break;
                case INT:
                    break;
                case FLOAT:
                    break;
                default:
                     System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + iexpr.getType().toString() + " no valido para print");
                    break;
            }
        }
        RESULT = new Expresion("null", TypeEx.NULL);
    :}
    | NARRA ABRECUENTO CIERRACUENTO FINREGALO
    {:
        RESULT = new Expresion("null", TypeEx.NULL);
    :}
    | ESCUCHA ABRECUENTO incienzo_expression:iexpr CIERRACUENTO FINREGALO
    {:
        var type = ((Expresion)iexpr).getType();;
            switch (type){
            case INT:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
            case FLOAT:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
            default:
                System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + type.toString() + " no valido para read");
                break;
            } 
        RESULT = new Expresion("null", TypeEx.NULL);
    :};

//llamada a funcion
belen_function_call_expression ::= PERSONA:id ABRECUENTO reyes_magicos_list_expr:listArgs CIERRACUENTO 
    {:
        RESULT = new Expresion("null", TypeEx.NULL);
        var fidentifier = FunctionManager.findFunction(id.toString());
        if (fidentifier == null){
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " no declarada todavía.");
        } else {
            var argsTypes = fidentifier.getTiposParametros();
            var expr_args = (ArrayList<Expresion>)listArgs;
            var validTypes = true;

            if (argsTypes.length != expr_args.size()) {
                validTypes = false;
                System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Numero de argumentos incorrecto para funcion " + id.toString());
            }
            else {
                for (int i = 0; i < argsTypes.length; i++) {
                    if (argsTypes[i] != expr_args.get(i).getType()) {
                        validTypes = false;
                        System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de argumento " + (i+1) + " incorrecto para funcion " + id.toString());
                        break;
                    }
                }
            }
            if (validTypes) {
                RESULT = new Expresion("null", fidentifier.getTipoRetorno());
            }
        }
    :}
    | PERSONA:id ABRECUENTO CIERRACUENTO
    {:
        RESULT = new Expresion("null", TypeEx.NULL);
        var fidentifier = FunctionManager.findFunction(id.toString());
        if (fidentifier == null) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " no declarada todavía.");
        }
        else {
            if (fidentifier.getTiposParametros().length != 0) {
                System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " no tiene parametros");
            }
            else {            
                RESULT = new Expresion("null", fidentifier.getTipoRetorno());
            }
        } 
    :};

//bloque de codigo
calcetin_compound_statement ::= ABREREGALO CIERRAREGALO
	| ABREREGALO empaque_block_item_list CIERRAREGALO
	;

//items de bloque de codigo
empaque_block_item_list ::= carta_block_item | empaque_block_item_list carta_block_item;

//elementos de bloque de codigo
carta_block_item ::= statement_risa_santa;

//estatuos logicos	
deseos_selection_statement ::= lapiz_papel_if_statement 
    {:
        
        SymbolTableManager.popPila();
    :}
	| lapiz_papel_if_statement DUENDE calcetin_compound_statement                                    // if () {} else {};
    {:
        
        SymbolTableManager.popPila();
    :}
    | lapiz_papel_if_statement tradiciones_elif_lista_statements                                              // if () {} elif () {} ;                              
    {:
        
        SymbolTableManager.popPila();
    :}
    | lapiz_papel_if_statement tradiciones_elif_lista_statements DUENDE calcetin_compound_statement           // if () {} elif () {} else() {};
    {:
        
        SymbolTableManager.popPila();
    :}
    ;

lapiz_papel_if_statement ::= ELFO 
    {:
        SymbolTableManager.pushPila("if" + labelId);
        ++labelId;
    :} ABRECUENTO incienzo_expression:iexpr CIERRACUENTO 
    {:
        var expr = (Expresion)iexpr;
        
        if (expr.getType() != TypeEx.BOOL) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getType().toString() + " no valido para una expresion booleana");
        }
        else {
        }
    :}
    calcetin_compound_statement: b 
    {:
        
    :};


tradiciones_elif_lista_statements ::=  tradicion_elif_statement | tradiciones_elif_lista_statements tradicion_elif_statement;


//elifs
tradicion_elif_statement ::=  HADA  ABRECUENTO incienzo_expression:iexpr CIERRACUENTO 
    {:
        
        var expr = (Expresion)iexpr;
        if (expr.getType() != TypeEx.BOOL) {
        System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getType().toString() + " no valido para una expresion booleana");
        }
        else {
        }
    :} calcetin_compound_statement {:
        
        ++labelId;
    :};
    
//iterracion
caramelo_iteration_statement ::= HACE  
    {:
        String label = "do" + labelId;
        SymbolTableManager.pushPila(label);
        ++labelId;
    :}statement_risa_santa:statementr REVISA ABRECUENTO incienzo_expression:iexpra CIERRACUENTO FINREGALO //do while
    {: 
        var expra = (Expresion)iexpra;
        if (expra.getType() != TypeEx.BOOL) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expra.getType().toString() + " no valido para una expresion booleana");
        }
        else {
            
            SymbolTableManager.popPila();
    }
    :}
	| ENVUELVE ABRECUENTO PERSONA:id ENTREGA incienzo_expression:iexpra 
    {:
        var expr = (Expresion)iexpra;
        var tipoId = SymbolTableManager.getIdType(id.toString(), true, lex.getLine(), lex.getColumn());
        if (tipoId != expr.getType()) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getType().toString() + " no valido para una variable de tipo " + tipoId.toString());
        }
        var label = "for" + labelId;
        SymbolTableManager.pushPila(label);
        ++labelId;
    :} CHIMENEA incienzo_expression:iexprb 
    {:
        var exprb = (Expresion)iexprb;
        
        if (exprb.getType() != TypeEx.BOOL) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + exprb.getType().toString() + " no valido para una expresion booleana");
        }
        else {

        }
    :} CHIMENEA {:
        
       
    :} incienzo_expression:iexpr {:
        
        
    :}CIERRACUENTO statement_risa_santa {:
        
    
        SymbolTableManager.popPila();
    :}//for
	;

//terminacion de ciclos y retornos
calcetin_jump_statement ::= CORTA FINREGALO 
    {: validarScopeSalto(lex.getLine(), lex.getLine(),"Break"):}                                          //break
	| ENVIA FINREGALO                           //return|
    {:pushPila(validarScopeSalto(lex.getLine(), lex.getLine(),"Return"):}
	| ENVIA incienzo_expression:expr FINREGALO       //return 5+2|
    {:

        var type = ((Expresion)expr).getType();
        var typeFuncReturn = FunctionManager.functionActual().getTipoRetorno();
        if (type != typeFuncReturn) {
            System.out.println("Error semántico: retorno de tipo " + type.toString() + "no coincide con el tipo de retorno de su función (" + typeFuncReturn.toString());
        } else {
            FunctionManager.functionActual().setRetornaValor(true);
        }
    :}
	;

//inicializacion de un array 
nochebuena_initializer ::=  ABREREGALO reyes_magicos_list_expr:l CIERRAREGALO      // {1,2,3,4...}
    {:
        var arrL = (ArrayList<Expresion>)l;
        var isValid = true;

        TypeEx tipo = arrL.get(0).getType();
        if (tipo != TypeEx.INT && tipo != TypeEx.CHAR) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo.toString() + " no valido para arreglo");
            RESULT = new Expresion("null", TypeEx.NULL);
            isValid = false;
        }
        for (Expresion iexpr : arrL) {
            if (iexpr.getType() != tipo) {
                System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + iexpr.getType().toString() + " no valido para un literal de arreglo de tipo " + tipo.toString());
                RESULT = new Expresion("null", TypeEx.NULL);
                isValid = false;  
                break;
            }
        }
        if (isValid){
            if (tipo == TypeEx.INT) {
                RESULT = new Expresion(arrL, TypeEx.INT_ARRAY);
            }
            else {
                RESULT = new Expresion(arrL, TypeEx.CHAR_ARRAY);
            }
        }
    :}
    | ABREREGALO CIERRAREGALO ;


//asignacion de arrays (parte izquierda)
estrella_assign_array ::= LOCALCOLOCARREGALO:l gorro_navidad_type_specifier:ty PERSONA:id ABREEMPAQUE l_NOEL:l_int CIERRAEMPAQUE ENTREGA nochebuena_initializer:arrl //int id[4]
    {:
        if (!ty.toString().equals("int")  && !ty.toString().equals("char")) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + ty.toString() + " no valido para arreglo");
        }
        else {
            var earr = (Expresion)arrl;
            if (earr.getType() == TypeEx.NULL){
                System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Literal de arreglo mal formado");
            }
            else {
                TypeEx tipo = Expresion.tipoFromString(ty.toString() + "[]");
                if (earr.getType() != tipo){
                    System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + earr.getType().toString() + " no valido para una variable de tipo " + tipo.toString());
                }
                else {
                    var arr = (ArrayList<Expresion>)earr.getValue();
                    if ((int)l_int != arr.size()) {
                           System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Longitud de arreglo " + l_int + " no coincide con la longitud del literal de arreglo " + arr.size());
                        }
                    else {
                        if (getType(id.toString(), false) != TypeEx.NULL) {
                           System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
                        }
                        else {
                            SymbolTableManager.anadirSimbolo(new SymbolTObj("variable local", ty.toString(), id.toString()));
                        }
                    }
                }
            }
        }
    :}
    | LOCALCOLOCARREGALO gorro_navidad_type_specifier:ty PERSONA:id ABREEMPAQUE l_NOEL:l_int CIERRAEMPAQUE 
    {:
        if(!ty.toString().equals("int")  && !ty.toString().equals("char")){
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + ty.toString() + " no valido para arreglo");
        }
        else {
            var i_arr = (int)l_int;
            if (i_arr <= 0) {
                System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Longitud de arreglo " + i_arr + " no valida");
            }
            else {
                if (SymbolTableManager.getIdType(id.toString(), false, lex.getLine(), lex.getColumn()) != TypeEx.NULL) {
                    System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
                }
                else {
                    SymbolTableManager.anadirSimbolo(new SymbolTObj("variable local", ty.toString(), id.toString()));
                }
            }
        }
    :}
	;


decorativo_array_elem ::=  PERSONA:id ABREEMPAQUE incienzo_expression:iexpr CIERRAEMPAQUE      // llamada a elemento de un array id[4]                          
    {:
        var expr = (Expresion)iexpr;
        var type = expr.getType();
        var idType = SymbolTableManager.getIdType(id.toString(), true, lex.getLine(), lex.getColumn());
        RESULT = new Expresion("null", TypeEx.NULL);
        if (type != TypeEx.INT) {
            System.out.println("Error semántico: el dato de tipo " + type.toString() + "no puede ser usado para indexar un array. Linea: " + lex.getLine() + "columna: " + lex.getColumn());
        } else if(idType != TypeEx.INT_ARRAY && idType != TypeEx.CHAR_ARRAY){
            System.out.println("Error semántico: el dato de tipo " + type.toString() + "no corresponde a un array. Linea: " + lex.getLine() + "columna: " + lex.getColumn());
        } else {
            RESULT = new Expresion("arrAt", Expresion.fromArr(idType));
        };
    :};

//expresiones de asignacion 
candelabro_assignment_expression ::= LOCALCOLOCARREGALO:l gorro_navidad_type_specifier:ty PERSONA:id ENTREGA incienzo_expression:iexpr FINREGALO  //local int id = 5|
    {:
        if (SymbolTableManager.getIdType(id.toString(), false, lex.getLine(), lex.getColumn()) != TypeEx.NULL) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
        } else {
            var exprh = (Expresion)iexpr;
            if (exprh.getType() != Expresion.tipoFromString(ty.toString())) {
                System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + exprh.getType().toString() + " no valido para una variable de tipo " + ty.toString());
            } else {
                SymbolTableManager.anadirSimbolo(new SymbolTObj("local", ty.toString(), id.toString()));
            };
        }
    :}
    | LOCALCOLOCARREGALO gorro_navidad_type_specifier:ty PERSONA:id FINREGALO
    {:
        if (SymbolTableManager.getIdType(id.toString(), false, lex.getLine(), lex.getColumn()) != TypeEx.NULL) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
        }
        else {
            SymbolTableManager.anadirSimbolo(new SymbolTObj("variable local", ty.toString(), id.toString()));
        }
    :} 
    | PERSONA:id ENTREGA incienzo_expression:iexpr FINREGALO  //id = 5|
    {:
        var expr = (Expresion)iexpr;
        var idType = SymbolTableManager.getIdType(id.toString(), true, lex.getLine(), lex.getColumn());
        if (idType != expr.getType()) {
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getType().toString() + " no valido para una variable de tipo " + idType.toString());
        }
        else {
        
        }
    :}
    | estrella_assign_array FINREGALO   //local arr[4] = {1,2,3,4}
    | decorativo_array_elem:arre ENTREGA incienzo_expression:iexpr FINREGALO
    {:
        var expreaj = (Expresion)arre;
        var expre = (Expresion)iexpr;

        if (expreaj.getType() != expre.getType()){
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expre.getType().toString() + " no valido para una variable de tipo " + expreaj.getType().toString());
        } else if (expreaj.getType() == TypeEx.NULL){
            System.out.println("Error semántico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Asignación mal formada.");
        }
        else {

        }
    :}; // arr[4] = number

//argumentos para definicion de funciones 
pesebre_args ::=  pesebre_arg | pesebre_args CHIMENEA pesebre_arg| pesebre_args CHIMENEA error|error;

pesebre_arg ::= gorro_navidad_type_specifier:ty PERSONA:id  
    {:
        SymbolTableManager.anadirSimbolo(new SymbolTObj("argumento de funcion", ty.toString(), id.toString()));
        var type = ty.toString();
        FunctionManager.functionActual().addTipoParametro(Expresion.tipoFromString(type));
    :};

//llamada a funcion como statement
belen_function_call_statement::= belen_function_call_expression:fcexpr FINREGALO;

//expresiones 
incienzo_expression ::=
    // literales
    arbol_constant:c  
    {: 
        RESULT = c;                                          
    :}                   
    // Identificador
    | PERSONA:id    
    {:
        if (SymbolTableManager.getIdType(id.toString(), true, lex.getLine(), lex.getColumn()) != TypeEx.NULL){
            RESULT = new Expresion(id.toString(), SymbolTableManager.getIdType(id.toString(),true, lex.getLine(), lex.getColumn()));
        } else {
            RESULT = new Expresion("null", TypeEx.NULL);
        };
    :}                                        
    | decorativo_array_elem:iexpr  // llamada a elemento de un array id[4]                          
    {:
        RESULT = iexpr;
    :}  
    | ABRECUENTO incienzo_expression:iexpr CIERRACUENTO        // ( expresion )
    {:
        RESULT = iexpr;
    :}
    | bastoncillo_arithmetic_expr:iexpr                        // operacion aritmetica
    {:
        RESULT = iexpr;
    :}
    | leche_relational_expr:iexpr                              // operacion relacional
    {:
        RESULT = iexpr;
    :}
    | galleta_logic_expr:iexpr                                 // operacion logica
    {:
        RESULT = iexpr;
    :}
    | belen_function_call_expression:iexpr           // llamada a function 
    {:
        RESULT = iexpr;
    :}
    ;

// Expresiones aritméticas
bastoncillo_arithmetic_expr ::= 
    incienzo_expression:a TRUENO incienzo_expression:b         // Resta 
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("-", aexpr, bexpr, arrayValidTypes);

        switch(resultType){
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " - " + bexpr.getValue().toString(), TypeEx.INT);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " - " + bexpr.getValue().toString(), TypeEx.FLOAT);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | incienzo_expression:a RODOLFO incienzo_expression:b                                     // Suma
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("+", aexpr, bexpr, arrayValidTypes);

        switch(resultType){
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " + " + bexpr.getValue().toString(), TypeEx.INT);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " + " + bexpr.getValue().toString(), TypeEx.FLOAT);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | incienzo_expression:a JUGUETON incienzo_expression:b                                  // División 
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("/", aexpr, bexpr, arrayValidTypes);

        switch(resultType){
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " / " + bexpr.getValue().toString(), TypeEx.INT);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " / " + bexpr.getValue().toString(), TypeEx.FLOAT);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | incienzo_expression:a RELAMPAGO incienzo_expression:b                                  // Multiplicación
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("*", aexpr, bexpr, arrayValidTypes);

        switch(resultType){
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " * " + bexpr.getValue().toString(), TypeEx.INT);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " * " + bexpr.getValue().toString(), TypeEx.FLOAT);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | incienzo_expression:a CUPIDO incienzo_expression:b                                   // Modulo
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("~", aexpr, bexpr, arrayValidTypes);

        switch(resultType){
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " ~ " + bexpr.getValue().toString(), TypeEx.INT);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " ~ " + bexpr.getValue().toString(), TypeEx.FLOAT);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | incienzo_expression:a COMETA incienzo_expression:b                                        //Exponente
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT)); 
        var resultType = validarTipado("**", aexpr, bexpr, arrayValidTypes);

        switch(resultType){
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " ** " + bexpr.getValue().toString(), TypeEx.INT);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " ** " + bexpr.getValue().toString(), TypeEx.FLOAT);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | TRUENO incienzo_expression:a
    {:
        var aexpr = (Expresion)a;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT)); 
        var resultType = validarTipado("-", aexpr, arrayValidTypes);

        switch(resultType){
            case INT:
                RESULT = new Expresion(" - " + aexpr.getValue().toString(), TypeEx.INT);
                break;
            case FLOAT:
                RESULT = new Expresion(" - " + aexpr.getValue().toString(), TypeEx.FLOAT);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | QUIEN PERSONA:id                                                                                               // Incremento prefijo
    {:
        var resultType = SymbolTableManager.getIdType(id.toString(), false, lex.getLine(), lex.getColumn());
        if (resultType == TypeEx.NULL) {
            RESULT = new Expresion("null", TypeEx.NULL);
        } else {
            switch(resultType){
                case INT:
                    RESULT = new Expresion( id.toString() + " ++ ", TypeEx.INT);
                    break;
                case FLOAT:
                    RESULT = new Expresion(id.toString() + " ++ ", TypeEx.FLOAT);
                    break;
                default:
                    System.out.println("Error semántico: no es posible implementar la operación sobre tipos de dato:" + resultType.toString() + ". Error en línea " + lex.getLine() + " columna: " + lex.getColumn());
                    RESULT = new Expresion("null", TypeEx.NULL);
                    break;
            };
        };
    :}
    | GRINCH PERSONA:id                                                                                                   // Decremento prefijo
    {:
        var resultType = SymbolTableManager.getIdType(id.toString(), false, lex.getLine(), lex.getColumn());
        if (resultType == TypeEx.NULL) {
            RESULT = new Expresion("null", TypeEx.NULL);
        } else {
            switch(resultType){
                case INT:
                    RESULT = new Expresion(id.toString() + " -- ", TypeEx.INT);
                    break;
                case FLOAT:
                    RESULT = new Expresion(id.toString() + " -- ", TypeEx.FLOAT);
                    break;
                default:
                    System.out.println("Error semántico: no es posible implementar la operación sobre tipos de dato:" + resultType.toString() + ". Error en línea " + lex.getLine() + " columna: " + lex.getColumn());
                    RESULT = new Expresion("null", TypeEx.NULL);
                    break;
            };
        };
    :}
    | diciembre_operation_array                                                                                                                     // Decr o Incr con indice array
	;

//incremento o decremento con asignacion en arrays
diciembre_operation_array ::= GRINCH decorativo_array_elem:arrElem
        {:
        var arrElemExpr = (Expresion)arrElem;
        var resultType = validarTipado("--", arrElemExpr, new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT)));
        if (resultType == TypeEx.INT) {
            RESULT = new Expresion(arrElemExpr.getValue().toString() + "--", TypeEx.INT);
        }
        else {
            System.out.println("Error semántico: tipo de dato " + arrElemExpr.getType().toString() + " no es permitido para decremento. En la linea " + lex.getLine() + " columna " + lex.getColumn());
            RESULT = new Expresion("null", TypeEx.NULL);
        }
    :}
    | QUIEN decorativo_array_elem:arrElem
    {:
        var arrElemExpr = (Expresion)arrElem;
        var resultType = validarTipado("++", arrElemExpr, new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT)));
        if (resultType == TypeEx.INT) {
            RESULT = new Expresion(arrElemExpr.getValue().toString() + "++", TypeEx.INT);
        }
        else {
            System.out.println("Error semántico: tipo de dato " + arrElemExpr.getType().toString() + " no es permitido para incremento. En la linea " + lex.getLine() + " columna " + lex.getColumn());
            RESULT = new Expresion("null", TypeEx.NULL);
        }
    :}
    ; 



// Expresiones relacionales
leche_relational_expr ::= 
    incienzo_expression:a ALABASTRO incienzo_expression:b         // Igual
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT, TypeEx.BOOL));
        var resultType = validarTipado("==", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
            case INT:
            case BOOL: 
                RESULT = new Expresion(aexpr.getValue().toString() + " == " + bexpr.getValue().toString(), TypeEx.BOOL);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " == " + bexpr.getValue().toString(), TypeEx.BOOL);
                break; 
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | incienzo_expression:a MINSTIX incienzo_expression:b                              // Menor que
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("<", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " < " + bexpr.getValue().toString(), TypeEx.BOOL);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " < " + bexpr.getValue().toString(), TypeEx.BOOL);
                break; 
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    | incienzo_expression:a UPATREE incienzo_expression:b                              // Mayor que
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado(">", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
        case INT:
            RESULT = new Expresion(aexpr.getValue().toString() + " > " + bexpr.getValue().toString(), TypeEx.BOOL);
            break;
        case FLOAT:
            RESULT = new Expresion(aexpr.getValue().toString() + " > " + bexpr.getValue().toString(), TypeEx.BOOL);
            break; 
        default:
            RESULT = new Expresion("null", TypeEx.NULL);
            break;
        };
    :}
    | incienzo_expression:a MARY incienzo_expression:b                              // Mayor o igual
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("=>", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
        case INT:
            RESULT = new Expresion(aexpr.getValue().toString() + " =>" + bexpr.getValue().toString(), TypeEx.BOOL);
            break;
        case FLOAT:
            RESULT = new Expresion(aexpr.getValue().toString() + " => " + bexpr.getValue().toString(), TypeEx.BOOL);
            break; 
        default:
            RESULT = new Expresion("null", TypeEx.NULL);
            break;
        };
    :}
    | incienzo_expression:a OPENSLAE incienzo_expression:b                              // Menor o igual
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT));
        var resultType = validarTipado("=<", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
            case INT:
                RESULT = new Expresion(aexpr.getValue().toString() + " =<" + bexpr.getValue().toString(), TypeEx.BOOL);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " =< " + bexpr.getValue().toString(), TypeEx.BOOL);
                break; 
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
            };
    :}
    | incienzo_expression:a EVERGEEN incienzo_expression:b                              // No igual
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.INT, TypeEx.FLOAT, TypeEx.BOOL));
        var resultType = validarTipado("!=", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
            case INT:
            case BOOL: 
                RESULT = new Expresion(aexpr.getValue().toString() + " != " + bexpr.getValue().toString(), TypeEx.BOOL);
                break;
            case FLOAT:
                RESULT = new Expresion(aexpr.getValue().toString() + " != " + bexpr.getValue().toString(), TypeEx.BOOL);
                break; 
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        };
    :}
    ;


// Expresiones lógicas
galleta_logic_expr ::= 
    incienzo_expression:a GASPAR incienzo_expression:b               // Y lógico
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.BOOL));
        var resultType = validarTipado(" ^ ", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
            case BOOL:
                RESULT = new Expresion(aexpr.getValue().toString() + " ^ " + bexpr.getValue().toString(), TypeEx.BOOL);
                break;
            default:
                RESULT = new Expresion("null", TypeEx.NULL);
                break;
        }
    :}
    | incienzo_expression:a MELCHOR incienzo_expression:b                               // O lógico
    {:
        var aexpr = (Expresion)a;
        var bexpr = (Expresion)b;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.BOOL));
        var resultType = validarTipado(" # ", aexpr, bexpr, arrayValidTypes);
        switch (resultType) {
        case BOOL:
            RESULT = new Expresion(aexpr.getValue().toString() + " # " + bexpr.getValue().toString(), TypeEx.BOOL);
            break;
        default:
            RESULT = new Expresion("null", TypeEx.NULL);
            break;
        }
    :}
    | BALTASAR incienzo_expression:a // Negación lógica                               // No lógico
    {:
        var aexpr = (Expresion)a;
        var arrayValidTypes = new ArrayList<TypeEx>(Arrays.asList(TypeEx.BOOL));
        var resultType = validarTipado(" ! ", aexpr, arrayValidTypes);
        switch (resultType) {
        case BOOL:
            RESULT = new Expresion(" ! " + aexpr.getValue().toString(), TypeEx.BOOL);
            break;
        default:
            RESULT = new Expresion("null", TypeEx.NULL);
            break;
        }
    :};
