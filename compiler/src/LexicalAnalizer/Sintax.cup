package LexicalAnalizer;
import java_cup.runtime.*;

action code {:
    public void uno(){
        System.out.println("123");
    }
    public void dos(){
        System.out.println("456");
    }
:}

parser code {:
  LexerCup lex;
  @SuppressWarnings("deprecation")
  public Sintax(LexerCup lex){
    this.lex=lex;
    this.symbolFactory= new DefaultSymbolFactory();
  }
:}

init with {: :};

scan with {: return lex.next_token(); :};

// Terminals

// Data Types
terminal NOEL, NICOLAS, SANTA, COLACHO, CLAUS;

//Parenthesis
terminal ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO;

//Separator
terminal CHIMENEA;

// Control Structures
terminal ELFO, HADA, DUENDE, ENVUELVE, HACE, REVISA, ENVIA, CORTA;

//Literals numbers
terminal l_NICOLAS, l_NOEL;

//Literal strings
terminal l_SANTA;

//Literal char
terminal l_COLACHO;

// Input/Output Functions
terminal NARRA, ESCUCHA;

// Class Types
terminal MOTIVO, FESTIVAL, FIESTA, NAVIDAD;

//null
terminal NARIZROJA;

//void 
terminal SINREGALO;

// Relational Operators
terminal ALABASTRO, EVERGEEN, UPATREE, MINSTIX, MARY, OPENSLAE;

// Logical Operators
terminal GASPAR, MELCHOR, BALTASAR;

// Assignment
terminal ENTREGA;

// Boolean Literals
terminal l_t_CLAUS, l_f_CLAUS;

// Unary Operators
terminal GRINCH, QUIEN;

// Binary Arithmetic Operators
terminal RODOLFO, TRUENO, RELAMPAGO, JUGUETON, COMETA, CUPIDO;

//Functions
terminal RECORRIDO;

// Identifier
terminal PERSONA;

// End of Line
terminal FINREGALO;

// Lexical Error
terminal ERRORNOTRECOGNIZED;

//no terminal 







non terminal   main, external_declaration, function_definition, type_specifier, statement, io_statement, function_call_statement,
               compound_statement, block_item_list, block_item, expression_statement, selection_statement, 
			   elif_statement, iteration_statement, jump_statement, initializer, initializer_list, initializer_list_integer,
			   initializer_list_char, assign_array, assignment_expression, args, expression, ArithmeticExpr, LogicalExpr, 
			   RelationalExpr;

// Precedence and associativity
precedence left MELCHOR, GASPAR;
precedence left ALABASTRO, EVERGEEN;
precedence left MINSTIX, UPATREE, OPENSLAE, MARY;
precedence left RODOLFO, TRUENO;
precedence left RELAMPAGO, JUGUETON, CUPIDO; // Including Modulo with same precedence as multiplication and division
precedence right BALTASAR, TRUENO; // Unary minus
precedence right QUIEN, GRINCH; // Increment and decrement
precedence left ABRECUENTO, CIERRACUENTO;		   

start with main;

main ::= external_declaration
	| main external_declaration
	;


external_declaration ::= function_definition | statement; 


function_definition ::= type_specifier RECORRIDO PERSONA ABRECUENTO args CIERRACUENTO compound_statement
    | type_specifier RECORRIDO PERSONA ABRECUENTO  CIERRACUENTO compound_statement;


//constant ::= l_NOEL	| l_NICOLAS | l_COLACHO | l_SANTA l_t_CLAUS | l_f_CLAUS;


type_specifier ::= SINREGALO
  | COLACHO
  | SANTA
  | NOEL
  | NICOLAS
  | CLAUS
  ;


statement ::= compound_statement
	| assignment_expression
	| selection_statement
	| iteration_statement
	| jump_statement
    | io_statement
	| function_call_statement
	;

io_statement ::= NARRA ABRECUENTO l_SANTA CIERRACUENTO FINREGALO
  | ESCUCHA ABRECUENTO l_SANTA CIERRACUENTO FINREGALO 
  ;

function_call_statement ::= PERSONA ABRECUENTO args CIERRACUENTO FINREGALO;

compound_statement ::= ABREREGALO CIERRAREGALO
	| ABREREGALO  block_item_list CIERRAREGALO
	;

block_item_list ::= block_item | block_item_list block_item;

block_item ::= statement;

expression_statement ::= FINREGALO
	| expression FINREGALO
	;
	
selection_statement ::= ELFO ABRECUENTO expression CIERRACUENTO compound_statement FINREGALO                                             // if () {};
	| ELFO ABRECUENTO expression CIERRACUENTO compound_statement DUENDE compound_statement FINREGALO                             // if () {} else {};
    | ELFO ABRECUENTO expression CIERRACUENTO compound_statement elif_statement DUENDE compound_statement FINREGALO           // if () {} elif () {} else() {};
	;

elif_statement ::=  HADA  ABRECUENTO expression CIERRACUENTO compound_statement
	| elif_statement HADA  ABRECUENTO expression CIERRACUENTO compound_statement;


iteration_statement ::= HACE statement REVISA ABRECUENTO expression CIERRACUENTO FINREGALO
	| ENVUELVE ABRECUENTO expression_statement expression_statement CIERRACUENTO statement
	;

jump_statement ::= CORTA FINREGALO
	| ENVIA FINREGALO
	| ENVIA expression
	;

initializer ::=  ABREREGALO initializer_list CIERRAREGALO
    | ABREREGALO CIERRAREGALO ;

initializer_list ::= initializer_list_integer | initializer_list_char;

initializer_list_integer ::= l_NOEL | initializer_list_integer CHIMENEA l_NOEL ;

initializer_list_char ::= l_COLACHO | initializer_list_char CHIMENEA l_COLACHO ;


assign_array ::= type_specifier PERSONA ABREEMPAQUE CIERRAEMPAQUE 
	| type_specifier ABREEMPAQUE CIERRAEMPAQUE
	| type_specifier PERSONA ABREEMPAQUE NOEL CIERRAEMPAQUE 
	| type_specifier ABREEMPAQUE NOEL CIERRAEMPAQUE
	;

assignment_expression ::= type_specifier PERSONA ENTREGA expression FINREGALO
	| assign_array ENTREGA initializer FINREGALO
	| assign_array FINREGALO
	| assign_array ENTREGA expression FINREGALO
	;

args ::= type_specifier PERSONA | args CHIMENEA type_specifier PERSONA;

expression ::= ArithmeticExpr
       | LogicalExpr
       | RelationalExpr
       | l_NOEL // Literal entero
       | l_NICOLAS // Literal flotante
	   | NARIZROJA
       | PERSONA  // Identificador
	   ;


// Expresiones aritméticas
ArithmeticExpr ::= expression RODOLFO expression // Suma
    | expression TRUENO expression // Resta
    | expression RELAMPAGO expression // Multiplicación
    | expression JUGUETON expression // División
    | expression CUPIDO expression // Modulo
    | QUIEN PERSONA %prec QUIEN // Incremento prefijo
    | GRINCH PERSONA %prec GRINCH // Decremento prefijo
    | ABRECUENTO expression CIERRACUENTO // Expresiones entre paréntesis
	;

// Expresiones lógicas
LogicalExpr ::= expression GASPAR expression // Y lógico
    | expression MELCHOR expression // O lógico
    | BALTASAR expression // Negación lógica
    | l_t_CLAUS // Literal 'true'
    | l_f_CLAUS // Literal 'false'
	;

// Expresiones relacionales
RelationalExpr ::= expression ALABASTRO expression // Igual
    | expression EVERGEEN expression // No igual
    | expression MINSTIX expression // Menor que
    | expression UPATREE expression // Mayor que
    | expression OPENSLAE expression // Menor o igual
    | expression MARY expression // Mayor o igual
    ;


